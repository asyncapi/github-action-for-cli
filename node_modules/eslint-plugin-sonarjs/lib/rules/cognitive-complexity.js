"use strict";
/*
 * eslint-plugin-sonarjs
 * Copyright (C) 2018 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-3776
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var nodes_1 = require("../utils/nodes");
var locations_1 = require("../utils/locations");
var DEFAULT_THRESHOLD = 15;
var rule = {
    meta: {
        schema: [
            { type: "integer", minimum: 0 },
            {
                // internal parameter
                enum: ["sonar-runtime", "metric"],
            },
        ],
    },
    create: function (context) {
        var threshold = context.options[0] !== undefined ? context.options[0] : DEFAULT_THRESHOLD;
        var isFileComplexity = context.options.includes("metric");
        /** Complexity of the file */
        var fileComplexity = 0;
        /** Complexity of the current function if it is *not* considered nested to the first level function */
        var complexityIfNotNested = [];
        /** Complexity of the current function if it is considered nested to the first level function */
        var complexityIfNested = [];
        /** Current nesting level (number of enclosing control flow statements and functions) */
        var nesting = 0;
        /** Indicator if the current top level function has a structural (generated by control flow statements) complexity */
        var topLevelHasStructuralComplexity = false;
        /** Own (not including nested functions) complexity of the current top function */
        var topLevelOwnComplexity = [];
        /** Nodes that should increase nesting level  */
        var nestingNodes = new Set();
        /** Set of already considered (with already computed complexity) logical expressions */
        var consideredLogicalExpressions = new Set();
        /** Stack of enclosing functions */
        var enclosingFunctions = [];
        var secondLevelFunctions = [];
        return {
            ":function": function (node) {
                onEnterFunction(node);
            },
            ":function:exit": function (node) {
                onLeaveFunction(node);
            },
            "*": function (node) {
                if (nestingNodes.has(node)) {
                    nesting++;
                }
            },
            "*:exit": function (node) {
                if (nestingNodes.has(node)) {
                    nesting--;
                    nestingNodes.delete(node);
                }
            },
            Program: function () {
                fileComplexity = 0;
            },
            "Program:exit": function (node) {
                if (isFileComplexity) {
                    // as issues are the only communication channel of a rule
                    // we pass data as serialized json as an issue message
                    context.report({ node: node, message: fileComplexity.toString() });
                }
            },
            IfStatement: function (node) {
                visitIfStatement(node);
            },
            ForStatement: function (node) {
                visitLoop(node);
            },
            ForInStatement: function (node) {
                visitLoop(node);
            },
            ForOfStatement: function (node) {
                visitLoop(node);
            },
            DoWhileStatement: function (node) {
                visitLoop(node);
            },
            WhileStatement: function (node) {
                visitLoop(node);
            },
            SwitchStatement: function (node) {
                visitSwitchStatement(node);
            },
            ContinueStatement: function (node) {
                visitContinueOrBreakStatement(node);
            },
            BreakStatement: function (node) {
                visitContinueOrBreakStatement(node);
            },
            CatchClause: function (node) {
                visitCatchClause(node);
            },
            LogicalExpression: function (node) {
                visitLogicalExpression(node);
            },
            ConditionalExpression: function (node) {
                visitConditionalExpression(node);
            },
        };
        function onEnterFunction(node) {
            if (enclosingFunctions.length === 0) {
                // top level function
                topLevelHasStructuralComplexity = false;
                topLevelOwnComplexity = [];
                secondLevelFunctions = [];
            }
            else if (enclosingFunctions.length === 1) {
                // second level function
                complexityIfNotNested = [];
                complexityIfNested = [];
            }
            else {
                nesting++;
                nestingNodes.add(node);
            }
            enclosingFunctions.push(node);
        }
        function onLeaveFunction(node) {
            enclosingFunctions.pop();
            if (enclosingFunctions.length === 0) {
                // top level function
                if (topLevelHasStructuralComplexity) {
                    var totalComplexity_1 = topLevelOwnComplexity;
                    secondLevelFunctions.forEach(function (secondLevelFunction) {
                        totalComplexity_1 = totalComplexity_1.concat(secondLevelFunction.complexityIfNested);
                    });
                    checkFunction(totalComplexity_1, locations_1.getMainFunctionTokenLocation(node, nodes_1.getParent(context), context));
                }
                else {
                    checkFunction(topLevelOwnComplexity, locations_1.getMainFunctionTokenLocation(node, nodes_1.getParent(context), context));
                    secondLevelFunctions.forEach(function (secondLevelFunction) {
                        checkFunction(secondLevelFunction.complexityIfThisSecondaryIsTopLevel, locations_1.getMainFunctionTokenLocation(secondLevelFunction.node, secondLevelFunction.parent, context));
                    });
                }
            }
            else if (enclosingFunctions.length === 1) {
                // second level function
                secondLevelFunctions.push({
                    node: node,
                    parent: nodes_1.getParent(context),
                    complexityIfNested: complexityIfNested,
                    complexityIfThisSecondaryIsTopLevel: complexityIfNotNested,
                    loc: locations_1.getMainFunctionTokenLocation(node, nodes_1.getParent(context), context),
                });
            }
            else {
                // complexity of third+ level functions is computed in their parent functions
                // so we never raise an issue for them
            }
        }
        function visitIfStatement(ifStatement) {
            var parent = nodes_1.getParent(context);
            var ifLoc = locations_1.getFirstToken(ifStatement, context).loc;
            // if the current `if` statement is `else if`, do not count it in structural complexity
            if (nodes_1.isIfStatement(parent) && parent.alternate === ifStatement) {
                addComplexity(ifLoc);
            }
            else {
                addStructuralComplexity(ifLoc);
            }
            // always increase nesting level inside `then` statement
            nestingNodes.add(ifStatement.consequent);
            // if `else` branch is not `else if` then
            // - increase nesting level inside `else` statement
            // - add +1 complexity
            if (ifStatement.alternate && !nodes_1.isIfStatement(ifStatement.alternate)) {
                nestingNodes.add(ifStatement.alternate);
                var elseTokenLoc = locations_1.getFirstTokenAfter(ifStatement.consequent, context).loc;
                addComplexity(elseTokenLoc);
            }
        }
        function visitLoop(loop) {
            addStructuralComplexity(locations_1.getFirstToken(loop, context).loc);
            nestingNodes.add(loop.body);
        }
        function visitSwitchStatement(switchStatement) {
            addStructuralComplexity(locations_1.getFirstToken(switchStatement, context).loc);
            for (var _i = 0, _a = switchStatement.cases; _i < _a.length; _i++) {
                var switchCase = _a[_i];
                nestingNodes.add(switchCase);
            }
        }
        function visitContinueOrBreakStatement(statement) {
            if (statement.label) {
                addComplexity(locations_1.getFirstToken(statement, context).loc);
            }
        }
        function visitCatchClause(catchClause) {
            addStructuralComplexity(locations_1.getFirstToken(catchClause, context).loc);
            nestingNodes.add(catchClause.body);
        }
        function visitConditionalExpression(conditionalExpression) {
            var questionTokenLoc = locations_1.getFirstTokenAfter(conditionalExpression.test, context).loc;
            addStructuralComplexity(questionTokenLoc);
            nestingNodes.add(conditionalExpression.consequent);
            nestingNodes.add(conditionalExpression.alternate);
        }
        function visitLogicalExpression(logicalExpression) {
            if (!consideredLogicalExpressions.has(logicalExpression)) {
                var flattenedLogicalExpressions = flattenLogicalExpression(logicalExpression);
                var previous = void 0;
                for (var _i = 0, flattenedLogicalExpressions_1 = flattenedLogicalExpressions; _i < flattenedLogicalExpressions_1.length; _i++) {
                    var current = flattenedLogicalExpressions_1[_i];
                    if (!previous || previous.operator !== current.operator) {
                        var operatorTokenLoc = locations_1.getFirstTokenAfter(logicalExpression.left, context).loc;
                        addComplexity(operatorTokenLoc);
                    }
                    previous = current;
                }
            }
        }
        function flattenLogicalExpression(node) {
            if (nodes_1.isLogicalExpression(node)) {
                consideredLogicalExpressions.add(node);
                return __spreadArrays(flattenLogicalExpression(node.left), [node], flattenLogicalExpression(node.right));
            }
            return [];
        }
        function addStructuralComplexity(location) {
            var added = nesting + 1;
            var complexityPoint = { complexity: added, location: location };
            if (enclosingFunctions.length === 0) {
                // top level scope
                fileComplexity += added;
            }
            else if (enclosingFunctions.length === 1) {
                // top level function
                topLevelHasStructuralComplexity = true;
                topLevelOwnComplexity.push(complexityPoint);
            }
            else {
                // second+ level function
                complexityIfNested.push({ complexity: added + 1, location: location });
                complexityIfNotNested.push(complexityPoint);
            }
        }
        function addComplexity(location) {
            var complexityPoint = { complexity: 1, location: location };
            if (enclosingFunctions.length === 0) {
                // top level scope
                fileComplexity += 1;
            }
            else if (enclosingFunctions.length === 1) {
                // top level function
                topLevelOwnComplexity.push(complexityPoint);
            }
            else {
                // second+ level function
                complexityIfNested.push(complexityPoint);
                complexityIfNotNested.push(complexityPoint);
            }
        }
        function checkFunction(complexity, loc) {
            if (complexity === void 0) { complexity = []; }
            var complexityAmount = complexity.reduce(function (acc, cur) { return acc + cur.complexity; }, 0);
            fileComplexity += complexityAmount;
            if (isFileComplexity) {
                return;
            }
            if (complexityAmount > threshold) {
                var secondaryLocations = complexity.map(function (complexityPoint) {
                    var complexity = complexityPoint.complexity, location = complexityPoint.location;
                    var message = complexity === 1 ? "+1" : "+" + complexity + " (incl. " + (complexity - 1) + " for nesting)";
                    return locations_1.issueLocation(location, undefined, message);
                });
                locations_1.report(context, {
                    message: "Refactor this function to reduce its Cognitive Complexity from " + complexityAmount + " to the " + threshold + " allowed.",
                    loc: loc,
                }, secondaryLocations, complexityAmount - threshold);
            }
        }
    },
};
module.exports = rule;
//# sourceMappingURL=cognitive-complexity.js.map